# Digraph Entropy Calculation Analysis Report

## 概要
本レポートは，`digraph-inout-analysis` リポジトリにおける有向グラフのエントロピー計算の仕様（`AGENTS.md`）と，その実装（`src/digraph_inout_analysis/core.py`）の対応関係を数理的観点から整理したものです．

## 1. エントロピー計算の数理的仕様

単純なノード間の遷移確率（1階マルコフ過程）ではなく，**「どこから来たか」の履歴を考慮した条件付き確率**（2階マルコフ過程）に基づいてエントロピーを計算します．

### 記号の定義
- $X_t$: 時刻 $t$ における状態（ノード）
- $A \to B \to C$: 連続する3つの状態遷移（$X_{t-1}=A, X_t=B, X_{t+1}=C$）
- $Count(A \to B)$: 遷移 $A \to B$ の観測回数
- $Count(A \to B \to C)$: 軌道 $A \to B \to C$ の観測回数

### Step 1: 条件付き確率分布の計算
「現在 $B$ にいて，かつ直前に $A$ から遷移してきた」という条件の下で，次に $C_i$ へ遷移する確率 $P(C_i | B, A)$ を推定します．

$$ P(C_i | B, A) = P(X_{t+1}=C_i \mid X_t=B, X_{t-1}=A) \approx \frac{Count(A \to B \to C_i)}{\sum_{k} Count(A \to B \to C_k)} $$

### Step 2: Shannon Entropy の計算
各$A \to B$ 辺に対して，この条件付き確率分布のエントロピーを計算し，割り当てます．

$$ H(A \to B) = - \sum_{i} P(C_i | B, A) \log_2 P(C_i | B, A) $$

これにより，同じノード $B$ に到達する辺であっても，前状態（$A$ vs $X$）によって次の挙動予測の不確実性が異なる場合，それぞれ異なるエントロピー値が付与されます．

## 2. 実装詳細

### データ構造の拡張
`networkx.DiGraph` のエッジ属性として，単純な重みだけでなく，次のステップへのカウント情報を保持します．

- Edge $(u, v)$ attributes:
    - `'weight'`: $Count(u \to v)$
    - `'next_counts'`: 辞書 `{w: count}`．$Count(u \to v \to w)$ を保持．

### アルゴリズム (`src/digraph_inout_analysis/core.py`)

1.  **グラフ構築 (`build_transition_digraph`)**:
    与えられた単語列からトリプレット $(u, v, w)$ を走査し，エッジ $u \to v$ の `next_counts` 属性に $w$ の出現回数を加算記録します．

2.  **エントロピー計算 (`calculate_io_entropy`)**:
    各有向辺 $u \to v$ について：
    -   `next_counts` を取得（分布 $\{Count(u \to v \to w)\}_w$）．
    -   `scipy.stats.entropy` を用いてエントロピーを計算．
    -   結果を属性 `entropy` として保存．

### 検証結果
検証スクリプトにより，以下の挙動が確認されています．
- パターン1: $A \to B \to C$
- パターン2: $X \to B \to D$
この2つのフローが混在する場合、2階マルコフ過程に基づく現在の手法では：
- $A \to B$ の次は必ず $C$ であるため，エントロピーは **0.0 bit**．
- $X \to B$ の次は必ず $D$ であるため，エントロピーは **0.0 bit**．

文脈依存の決定論的な遷移を正しく「不確実性ゼロ」として評価できています．

## 3. 自己ループの取り扱いとシーケンス圧縮

本プロジェクトでは，ノードでの「滞在時間」を無視して「状態間の遷移構造」のみを抽出するためのオプション `ignore_self_loops=True` を提供しています．

### 自己ループを無視する際の課題
単純にトリプレット $(u, v, w)$ 走査時に $u=v$ をスキップするだけでは，2階マルコフ過程の整合性が保てません．
例えば，シーケンス `[A, A, B, B, C]` において，$A \to B$ の次に遷移する「異なる」状態は $C$ ですが，元の時系列で $B$ の直後は $B$（自己ループ）です．
単なるスキップでは，$A \to B$ の次の状態として $B$ がカウントされてしまい，グラフに含まれない自己ループへの遷移情報が混入してしまいます．

### 解決策：シーケンス圧縮 (Sequence Compression)
`ignore_self_loops=True` が指定された場合，グラフ構築の前に以下の「シーケンス圧縮」を適用します：

1.  **アルゴリズム**: 連続する同一の状態を1つにまとめます（`itertools.groupby` のキーを抽出）．
    -   入力: `[A, A, A, B, B, C, B, B]`
    -   出力: `[A, B, C, B]`
2.  **グラフ構築**: 圧縮後のシーケンスに対してペア $(u, v)$ およびトリプレット $(u, v, w)$ を走査します．

### 利点
- **純粋な状態遷移のエントロピー**: ノードでの滞在時間の長短に左右されず，「ある遷移の後にどのノードへ分岐するか」という構造的な不確実性のみを抽出できます．
- **実装の簡潔性**: 前処理（圧縮）だけで矛盾のない統計（`next_counts`）を得ることができます．

### `min_duration` との組み合わせ
`min_duration=n` フィルタと `ignore_self_loops=True` を組み合わせることで，「$n$ ステップ以上持続した安定状態のみを抽出し，かつその滞在時間を無視した遷移グラフ」を構築できます．

調査の結果，`min_duration=2` 以上の設定で自己ループを無視すると，決定論的な（分岐のない）遷移が支配的になり，エントロピーが 0 に収束する傾向があることが確認されました．これは，ノイズとしての短寿命な分岐ノードが除去された結果であり，数理的に妥当な挙動と考えられます．
## 4. 解析パイプラインの処理順序

論文の測定プロトコル（「10ステップ毎にデータをとる」等）との整合性を保つため，以下の順序でデータの変換とグラフの構築が行われます：

1.  **データ読み込み (`load_data_from_tsv`)**:
    -   指定されたカラムから `error` や `nan` を除外したシーケンスを取得します．
2.  **サンプリング (`step_size`)**:
    -   論文の仕様（例：`step_size=10`）に基づき，まず時系列データのダウンサンプリングを行います．これにより解析の基準となる時間解像度が決定されます．
3.  **短寿命状態のフィルタ (`min_duration`)**:
    -   サンプリング後の系列に対して適用されます．
    -   サンプリングされたデータポイントにおいて，$n$ 回分以上持続しなかった状態（例：1サンプル分しか現れない ephemeral な状態）を除外・短縮します．
4.  **シーケンス圧縮 (`ignore_self_loops`)**:
    -   `ignore_self_loops=True` の場合のみ実施されます．
    -   連続する同一の状態を1つに圧縮（`A A B B C -> A B C`）し，滞在時間を無視した純粋な状態遷移シーケンスを作成します．
5.  **グラフ・履歴構築 (`build_transition_digraph`)**:
    -   最終的なシーケンスから遷移ペアおよびトリプレットを走査し，重みと次状態分布を記録します．
6.  **エントロピー計算 (`calculate_io_entropy`)**:
    -   各エッジの履歴情報から条件付きエントロピーを算出します．

この順序により，論文の測定基準に準拠した解像度において，構造的に不安定（非持続的）なパターンの影響を排除した解析結果が得られます．
